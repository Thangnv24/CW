Цель работы: написать компилятор Бейсика в ассемблер реальной машины (x86-
32, x86-64, ARM) или виртуальной (LLVM, CIL1) по выбору студента.
Синтаксис диалекта реконструируется из примера кода, приведённого в приложении Б.
Язык реализации — любой на выбор студента.

_______________________________________________________________________________________

Приложение Б. Образец диалекта Бейсика для задания 14
Диалект Бейсика
' Суммирование элементов массива
Function SumArray#(Values#(ValCount%))
SumArray# = 0
For i% = 1 To ValCount%
SumArray# = SumArray# + Values#(i%)
Next i%
End Function
' Вычисление многочлена по схеме Горнера
Function Polynom!(x!, coefs!(n%))
Polynom! = 0
For i% = 1 to n%
Polynom! = Polynom! * x! + coefs!(i%)
Next i%
End Function
' Вычисление многочлена x³ + x² + x + 1
Function Polynom1111!(x!)
Dim coefs!(4)
For i% = 1 To 4
coefs!(i%) = 1
Next i%
Polynom1111! = Polynom!(x!, coefs!)
14
End Function
' Инициализация массива числами Фибоначчи
Sub Fibonacci(res&(n%))
If n% >= 1 Then
res&(1) = 1
End If
If n% >= 2 Then
res&(2) = 1
End If
i% = 3
Do While i% <= n%
res&(i%) = res&(i% - 1) + res&(i% - 2)
i% = i% + 1
Loop
End Sub
' Склеивание элементов массива через разделитель: Join$(", ", words)
Function Join$(sep$, items$(count%))
If count%% >= 1 Then
Join$ = items$(1)
Else
Join$ = ""
End If
For i% = 2 To count%
Join$ = Join$ + sep$ + items$(i%)
Next i%
End Function
' Главная процедура
Sub Main(argv$(argc%))
Print "Аргументы программы: ", Join$(", ", argv$)
' Объявление локального массива
Dim fibs&(100)
Fibonacci(fibs&)
Print "50-е число Фибоначчи — ", fibs&(50)
Dim ys#(101)
Print "Таблица значений функции y = x³ + x² + x + 1:"
15
For x% = -50 To 50
y! = Polynom1111!(x%)
Print "x = ", x%, ", y = ", y!
ys#(x% + 51) = y!
Next x%
Print "Сумма перечисленных значений y: ", SumArray#(ys#)
End Sub
Комментарии начинаются с апострофа ' и продолжаются до конца строки.
Идентификаторы и ключевые слова не чувствительны к регистру.
В имени каждой переменной и каждой функции указывается её тип (% — целое, & —
длинное целое, ! — вещественное одинарной точности, # — вещественное двойной
точности, $ — строка).
Внутри функции неявно объявляется переменная с тем же именем, что и имя самой
функции — её значение является возвращаемым значением функции.
И индексация массивов, и вызов функции записываются при помощи круглых
скобок — отличить одно от другого на этапе синтаксического анализа невозможно,
поэтому в дереве они различаться не должны.
Цикл с условием может быть записан пятью способами:
Do While … Do Until … Do Do Do
… … … … …
Loop Loop Loop While … Loop Until … Loop
Первые две формы — циклы с предусловием (положительным и отрицательным),
две другие — с постусловием и, наконец, пятая — бесконечный цикл.
Цикл For можно прерывать операторами
Exit For
Exit For i%
Первая форма прерывает текущий цикл, вторая (с переменной) позволяет прервать
сразу несколько вложенных циклов.
Цикл Do/Loop можно прервать любым из двух операторов (они синонимы):
Exit Do
Exit Loop
Процедуры и функции прерываются, соответственно, операторами
Exit Sub
Exit Function
Можно определять глобальные переменные:
16
Dim some_global_var%
Dim some_global_array%(100)
Можно определять многомерные массивы:
Dim matrix!(100, 100)
